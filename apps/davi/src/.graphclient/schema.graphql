schema {
  query: Query
  subscription: Subscription
}

"Marks the GraphQL type as indexable entity.  Each type that should be an entity is required to be annotated with this directive."
directive @entity on OBJECT

"Defined a Subgraph ID for an object type"
directive @subgraphId(id: String!) on OBJECT

"creates a virtual field on the entity that may be queried but cannot be set manually through the mappings API."
directive @derivedFrom(field: String!) on FIELD_DEFINITION

type Action {
  id: ID!
  optionId: String!
  to: String!
  data: String!
  value: BigInt!
  from: String!
}

input Action_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  optionId: String
  optionId_not: String
  optionId_gt: String
  optionId_lt: String
  optionId_gte: String
  optionId_lte: String
  optionId_in: [String!]
  optionId_not_in: [String!]
  optionId_contains: String
  optionId_contains_nocase: String
  optionId_not_contains: String
  optionId_not_contains_nocase: String
  optionId_starts_with: String
  optionId_starts_with_nocase: String
  optionId_not_starts_with: String
  optionId_not_starts_with_nocase: String
  optionId_ends_with: String
  optionId_ends_with_nocase: String
  optionId_not_ends_with: String
  optionId_not_ends_with_nocase: String
  to: String
  to_not: String
  to_gt: String
  to_lt: String
  to_gte: String
  to_lte: String
  to_in: [String!]
  to_not_in: [String!]
  to_contains: String
  to_contains_nocase: String
  to_not_contains: String
  to_not_contains_nocase: String
  to_starts_with: String
  to_starts_with_nocase: String
  to_not_starts_with: String
  to_not_starts_with_nocase: String
  to_ends_with: String
  to_ends_with_nocase: String
  to_not_ends_with: String
  to_not_ends_with_nocase: String
  data: String
  data_not: String
  data_gt: String
  data_lt: String
  data_gte: String
  data_lte: String
  data_in: [String!]
  data_not_in: [String!]
  data_contains: String
  data_contains_nocase: String
  data_not_contains: String
  data_not_contains_nocase: String
  data_starts_with: String
  data_starts_with_nocase: String
  data_not_starts_with: String
  data_not_starts_with_nocase: String
  data_ends_with: String
  data_ends_with_nocase: String
  data_not_ends_with: String
  data_not_ends_with_nocase: String
  value: BigInt
  value_not: BigInt
  value_gt: BigInt
  value_lt: BigInt
  value_gte: BigInt
  value_lte: BigInt
  value_in: [BigInt!]
  value_not_in: [BigInt!]
  from: String
  from_not: String
  from_gt: String
  from_lt: String
  from_gte: String
  from_lte: String
  from_in: [String!]
  from_not_in: [String!]
  from_contains: String
  from_contains_nocase: String
  from_not_contains: String
  from_not_contains_nocase: String
  from_starts_with: String
  from_starts_with_nocase: String
  from_not_starts_with: String
  from_not_starts_with_nocase: String
  from_ends_with: String
  from_ends_with_nocase: String
  from_not_ends_with: String
  from_not_ends_with_nocase: String
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
}

enum Action_orderBy {
  id
  optionId
  to
  data
  value
  from
}

scalar BigDecimal

scalar BigInt

input BlockChangedFilter {
  number_gte: Int!
}

input Block_height {
  hash: Bytes
  number: Int
  number_gte: Int
}

scalar Bytes

type Guild {
  id: ID!
  name: String
  token: Token
  permissionRegistry: String
  proposalTime: BigInt
  lockTime: BigInt
  timeForExecution: BigInt
  votingPowerForProposalCreation: BigInt
  votingPowerForProposalExecution: BigInt
  voteGas: BigInt
  maxGasPrice: BigInt
  maxActiveProposals: BigInt
  minimumMembersForProposalCreation: BigInt
  minimumTokensLockedForProposalCreation: BigInt
  type: GuildType
  permissions(skip: Int = 0, first: Int = 100, orderBy: GuildPermission_orderBy, orderDirection: OrderDirection, where: GuildPermission_filter): [GuildPermission!]!
  proposals(skip: Int = 0, first: Int = 100, orderBy: Proposal_orderBy, orderDirection: OrderDirection, where: Proposal_filter): [Proposal!]
  members(skip: Int = 0, first: Int = 100, orderBy: Member_orderBy, orderDirection: OrderDirection, where: Member_filter): [Member!]
  isActive: Boolean
  bytecodeHash: String
}

type GuildPermission {
  id: ID!
  from: String!
  to: String!
  functionSignature: Bytes!
  valueAllowed: BigInt!
  fromTime: BigInt!
  allowed: Boolean!
  guild: Guild
}

input GuildPermission_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  from: String
  from_not: String
  from_gt: String
  from_lt: String
  from_gte: String
  from_lte: String
  from_in: [String!]
  from_not_in: [String!]
  from_contains: String
  from_contains_nocase: String
  from_not_contains: String
  from_not_contains_nocase: String
  from_starts_with: String
  from_starts_with_nocase: String
  from_not_starts_with: String
  from_not_starts_with_nocase: String
  from_ends_with: String
  from_ends_with_nocase: String
  from_not_ends_with: String
  from_not_ends_with_nocase: String
  to: String
  to_not: String
  to_gt: String
  to_lt: String
  to_gte: String
  to_lte: String
  to_in: [String!]
  to_not_in: [String!]
  to_contains: String
  to_contains_nocase: String
  to_not_contains: String
  to_not_contains_nocase: String
  to_starts_with: String
  to_starts_with_nocase: String
  to_not_starts_with: String
  to_not_starts_with_nocase: String
  to_ends_with: String
  to_ends_with_nocase: String
  to_not_ends_with: String
  to_not_ends_with_nocase: String
  functionSignature: Bytes
  functionSignature_not: Bytes
  functionSignature_in: [Bytes!]
  functionSignature_not_in: [Bytes!]
  functionSignature_contains: Bytes
  functionSignature_not_contains: Bytes
  valueAllowed: BigInt
  valueAllowed_not: BigInt
  valueAllowed_gt: BigInt
  valueAllowed_lt: BigInt
  valueAllowed_gte: BigInt
  valueAllowed_lte: BigInt
  valueAllowed_in: [BigInt!]
  valueAllowed_not_in: [BigInt!]
  fromTime: BigInt
  fromTime_not: BigInt
  fromTime_gt: BigInt
  fromTime_lt: BigInt
  fromTime_gte: BigInt
  fromTime_lte: BigInt
  fromTime_in: [BigInt!]
  fromTime_not_in: [BigInt!]
  allowed: Boolean
  allowed_not: Boolean
  allowed_in: [Boolean!]
  allowed_not_in: [Boolean!]
  guild: String
  guild_not: String
  guild_gt: String
  guild_lt: String
  guild_gte: String
  guild_lte: String
  guild_in: [String!]
  guild_not_in: [String!]
  guild_contains: String
  guild_contains_nocase: String
  guild_not_contains: String
  guild_not_contains_nocase: String
  guild_starts_with: String
  guild_starts_with_nocase: String
  guild_not_starts_with: String
  guild_not_starts_with_nocase: String
  guild_ends_with: String
  guild_ends_with_nocase: String
  guild_not_ends_with: String
  guild_not_ends_with_nocase: String
  guild_: Guild_filter
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
}

enum GuildPermission_orderBy {
  id
  from
  to
  functionSignature
  valueAllowed
  fromTime
  allowed
  guild
}

enum GuildType {
  ERC20Guild
  DXDGuild
  SnapshotRepERC20Guild
  SnapshotERC20Guild
}

input Guild_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  name: String
  name_not: String
  name_gt: String
  name_lt: String
  name_gte: String
  name_lte: String
  name_in: [String!]
  name_not_in: [String!]
  name_contains: String
  name_contains_nocase: String
  name_not_contains: String
  name_not_contains_nocase: String
  name_starts_with: String
  name_starts_with_nocase: String
  name_not_starts_with: String
  name_not_starts_with_nocase: String
  name_ends_with: String
  name_ends_with_nocase: String
  name_not_ends_with: String
  name_not_ends_with_nocase: String
  token: String
  token_not: String
  token_gt: String
  token_lt: String
  token_gte: String
  token_lte: String
  token_in: [String!]
  token_not_in: [String!]
  token_contains: String
  token_contains_nocase: String
  token_not_contains: String
  token_not_contains_nocase: String
  token_starts_with: String
  token_starts_with_nocase: String
  token_not_starts_with: String
  token_not_starts_with_nocase: String
  token_ends_with: String
  token_ends_with_nocase: String
  token_not_ends_with: String
  token_not_ends_with_nocase: String
  token_: Token_filter
  permissionRegistry: String
  permissionRegistry_not: String
  permissionRegistry_gt: String
  permissionRegistry_lt: String
  permissionRegistry_gte: String
  permissionRegistry_lte: String
  permissionRegistry_in: [String!]
  permissionRegistry_not_in: [String!]
  permissionRegistry_contains: String
  permissionRegistry_contains_nocase: String
  permissionRegistry_not_contains: String
  permissionRegistry_not_contains_nocase: String
  permissionRegistry_starts_with: String
  permissionRegistry_starts_with_nocase: String
  permissionRegistry_not_starts_with: String
  permissionRegistry_not_starts_with_nocase: String
  permissionRegistry_ends_with: String
  permissionRegistry_ends_with_nocase: String
  permissionRegistry_not_ends_with: String
  permissionRegistry_not_ends_with_nocase: String
  proposalTime: BigInt
  proposalTime_not: BigInt
  proposalTime_gt: BigInt
  proposalTime_lt: BigInt
  proposalTime_gte: BigInt
  proposalTime_lte: BigInt
  proposalTime_in: [BigInt!]
  proposalTime_not_in: [BigInt!]
  lockTime: BigInt
  lockTime_not: BigInt
  lockTime_gt: BigInt
  lockTime_lt: BigInt
  lockTime_gte: BigInt
  lockTime_lte: BigInt
  lockTime_in: [BigInt!]
  lockTime_not_in: [BigInt!]
  timeForExecution: BigInt
  timeForExecution_not: BigInt
  timeForExecution_gt: BigInt
  timeForExecution_lt: BigInt
  timeForExecution_gte: BigInt
  timeForExecution_lte: BigInt
  timeForExecution_in: [BigInt!]
  timeForExecution_not_in: [BigInt!]
  votingPowerForProposalCreation: BigInt
  votingPowerForProposalCreation_not: BigInt
  votingPowerForProposalCreation_gt: BigInt
  votingPowerForProposalCreation_lt: BigInt
  votingPowerForProposalCreation_gte: BigInt
  votingPowerForProposalCreation_lte: BigInt
  votingPowerForProposalCreation_in: [BigInt!]
  votingPowerForProposalCreation_not_in: [BigInt!]
  votingPowerForProposalExecution: BigInt
  votingPowerForProposalExecution_not: BigInt
  votingPowerForProposalExecution_gt: BigInt
  votingPowerForProposalExecution_lt: BigInt
  votingPowerForProposalExecution_gte: BigInt
  votingPowerForProposalExecution_lte: BigInt
  votingPowerForProposalExecution_in: [BigInt!]
  votingPowerForProposalExecution_not_in: [BigInt!]
  voteGas: BigInt
  voteGas_not: BigInt
  voteGas_gt: BigInt
  voteGas_lt: BigInt
  voteGas_gte: BigInt
  voteGas_lte: BigInt
  voteGas_in: [BigInt!]
  voteGas_not_in: [BigInt!]
  maxGasPrice: BigInt
  maxGasPrice_not: BigInt
  maxGasPrice_gt: BigInt
  maxGasPrice_lt: BigInt
  maxGasPrice_gte: BigInt
  maxGasPrice_lte: BigInt
  maxGasPrice_in: [BigInt!]
  maxGasPrice_not_in: [BigInt!]
  maxActiveProposals: BigInt
  maxActiveProposals_not: BigInt
  maxActiveProposals_gt: BigInt
  maxActiveProposals_lt: BigInt
  maxActiveProposals_gte: BigInt
  maxActiveProposals_lte: BigInt
  maxActiveProposals_in: [BigInt!]
  maxActiveProposals_not_in: [BigInt!]
  minimumMembersForProposalCreation: BigInt
  minimumMembersForProposalCreation_not: BigInt
  minimumMembersForProposalCreation_gt: BigInt
  minimumMembersForProposalCreation_lt: BigInt
  minimumMembersForProposalCreation_gte: BigInt
  minimumMembersForProposalCreation_lte: BigInt
  minimumMembersForProposalCreation_in: [BigInt!]
  minimumMembersForProposalCreation_not_in: [BigInt!]
  minimumTokensLockedForProposalCreation: BigInt
  minimumTokensLockedForProposalCreation_not: BigInt
  minimumTokensLockedForProposalCreation_gt: BigInt
  minimumTokensLockedForProposalCreation_lt: BigInt
  minimumTokensLockedForProposalCreation_gte: BigInt
  minimumTokensLockedForProposalCreation_lte: BigInt
  minimumTokensLockedForProposalCreation_in: [BigInt!]
  minimumTokensLockedForProposalCreation_not_in: [BigInt!]
  type: GuildType
  type_not: GuildType
  type_in: [GuildType!]
  type_not_in: [GuildType!]
  permissions_: GuildPermission_filter
  proposals: [String!]
  proposals_not: [String!]
  proposals_contains: [String!]
  proposals_contains_nocase: [String!]
  proposals_not_contains: [String!]
  proposals_not_contains_nocase: [String!]
  proposals_: Proposal_filter
  members: [String!]
  members_not: [String!]
  members_contains: [String!]
  members_contains_nocase: [String!]
  members_not_contains: [String!]
  members_not_contains_nocase: [String!]
  members_: Member_filter
  isActive: Boolean
  isActive_not: Boolean
  isActive_in: [Boolean!]
  isActive_not_in: [Boolean!]
  bytecodeHash: String
  bytecodeHash_not: String
  bytecodeHash_gt: String
  bytecodeHash_lt: String
  bytecodeHash_gte: String
  bytecodeHash_lte: String
  bytecodeHash_in: [String!]
  bytecodeHash_not_in: [String!]
  bytecodeHash_contains: String
  bytecodeHash_contains_nocase: String
  bytecodeHash_not_contains: String
  bytecodeHash_not_contains_nocase: String
  bytecodeHash_starts_with: String
  bytecodeHash_starts_with_nocase: String
  bytecodeHash_not_starts_with: String
  bytecodeHash_not_starts_with_nocase: String
  bytecodeHash_ends_with: String
  bytecodeHash_ends_with_nocase: String
  bytecodeHash_not_ends_with: String
  bytecodeHash_not_ends_with_nocase: String
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
}

enum Guild_orderBy {
  id
  name
  token
  permissionRegistry
  proposalTime
  lockTime
  timeForExecution
  votingPowerForProposalCreation
  votingPowerForProposalExecution
  voteGas
  maxGasPrice
  maxActiveProposals
  minimumMembersForProposalCreation
  minimumTokensLockedForProposalCreation
  type
  permissions
  proposals
  members
  isActive
  bytecodeHash
}

type Member {
  id: ID!
  address: String!
  tokensLocked: BigInt!
}

input Member_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  address: String
  address_not: String
  address_gt: String
  address_lt: String
  address_gte: String
  address_lte: String
  address_in: [String!]
  address_not_in: [String!]
  address_contains: String
  address_contains_nocase: String
  address_not_contains: String
  address_not_contains_nocase: String
  address_starts_with: String
  address_starts_with_nocase: String
  address_not_starts_with: String
  address_not_starts_with_nocase: String
  address_ends_with: String
  address_ends_with_nocase: String
  address_not_ends_with: String
  address_not_ends_with_nocase: String
  tokensLocked: BigInt
  tokensLocked_not: BigInt
  tokensLocked_gt: BigInt
  tokensLocked_lt: BigInt
  tokensLocked_gte: BigInt
  tokensLocked_lte: BigInt
  tokensLocked_in: [BigInt!]
  tokensLocked_not_in: [BigInt!]
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
}

enum Member_orderBy {
  id
  address
  tokensLocked
}

type Option {
  id: ID!
  label: String
  proposalId: String
  actions(skip: Int = 0, first: Int = 100, orderBy: Action_orderBy, orderDirection: OrderDirection, where: Action_filter): [Action!]
  voteAmount: BigInt
  votes(skip: Int = 0, first: Int = 100, orderBy: Vote_orderBy, orderDirection: OrderDirection, where: Vote_filter): [Vote!]!
}

input Option_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  label: String
  label_not: String
  label_gt: String
  label_lt: String
  label_gte: String
  label_lte: String
  label_in: [String!]
  label_not_in: [String!]
  label_contains: String
  label_contains_nocase: String
  label_not_contains: String
  label_not_contains_nocase: String
  label_starts_with: String
  label_starts_with_nocase: String
  label_not_starts_with: String
  label_not_starts_with_nocase: String
  label_ends_with: String
  label_ends_with_nocase: String
  label_not_ends_with: String
  label_not_ends_with_nocase: String
  proposalId: String
  proposalId_not: String
  proposalId_gt: String
  proposalId_lt: String
  proposalId_gte: String
  proposalId_lte: String
  proposalId_in: [String!]
  proposalId_not_in: [String!]
  proposalId_contains: String
  proposalId_contains_nocase: String
  proposalId_not_contains: String
  proposalId_not_contains_nocase: String
  proposalId_starts_with: String
  proposalId_starts_with_nocase: String
  proposalId_not_starts_with: String
  proposalId_not_starts_with_nocase: String
  proposalId_ends_with: String
  proposalId_ends_with_nocase: String
  proposalId_not_ends_with: String
  proposalId_not_ends_with_nocase: String
  actions: [String!]
  actions_not: [String!]
  actions_contains: [String!]
  actions_contains_nocase: [String!]
  actions_not_contains: [String!]
  actions_not_contains_nocase: [String!]
  actions_: Action_filter
  voteAmount: BigInt
  voteAmount_not: BigInt
  voteAmount_gt: BigInt
  voteAmount_lt: BigInt
  voteAmount_gte: BigInt
  voteAmount_lte: BigInt
  voteAmount_in: [BigInt!]
  voteAmount_not_in: [BigInt!]
  votes: [String!]
  votes_not: [String!]
  votes_contains: [String!]
  votes_contains_nocase: [String!]
  votes_not_contains: [String!]
  votes_not_contains_nocase: [String!]
  votes_: Vote_filter
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
}

enum Option_orderBy {
  id
  label
  proposalId
  actions
  voteAmount
  votes
}

"""Defines the order direction, either ascending or descending"""
enum OrderDirection {
  asc
  desc
}

type Proposal {
  id: ID!
  creator: String!
  startTime: BigInt!
  endTime: BigInt!
  to: [String!]
  data: [String!]
  value: [BigInt!]
  title: String!
  contentHash: String!
  contractState: BigInt!
  guildId: String!
  totalVotes: [BigInt!]
  votes(skip: Int = 0, first: Int = 100, orderBy: Vote_orderBy, orderDirection: OrderDirection, where: Vote_filter): [Vote!]
  options(skip: Int = 0, first: Int = 100, orderBy: Option_orderBy, orderDirection: OrderDirection, where: Option_filter): [Option!]
  metadata: String
  description: String
  executionTransactionHash: String
  statesLog(skip: Int = 0, first: Int = 100, orderBy: ProposalStateLog_orderBy, orderDirection: OrderDirection, where: ProposalStateLog_filter): [ProposalStateLog!]
}

type ProposalStateLog {
  id: ID!
  state: BigInt!
  timestamp: BigInt!
  transactionHash: String!
}

input ProposalStateLog_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  state: BigInt
  state_not: BigInt
  state_gt: BigInt
  state_lt: BigInt
  state_gte: BigInt
  state_lte: BigInt
  state_in: [BigInt!]
  state_not_in: [BigInt!]
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  transactionHash: String
  transactionHash_not: String
  transactionHash_gt: String
  transactionHash_lt: String
  transactionHash_gte: String
  transactionHash_lte: String
  transactionHash_in: [String!]
  transactionHash_not_in: [String!]
  transactionHash_contains: String
  transactionHash_contains_nocase: String
  transactionHash_not_contains: String
  transactionHash_not_contains_nocase: String
  transactionHash_starts_with: String
  transactionHash_starts_with_nocase: String
  transactionHash_not_starts_with: String
  transactionHash_not_starts_with_nocase: String
  transactionHash_ends_with: String
  transactionHash_ends_with_nocase: String
  transactionHash_not_ends_with: String
  transactionHash_not_ends_with_nocase: String
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
}

enum ProposalStateLog_orderBy {
  id
  state
  timestamp
  transactionHash
}

input Proposal_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  creator: String
  creator_not: String
  creator_gt: String
  creator_lt: String
  creator_gte: String
  creator_lte: String
  creator_in: [String!]
  creator_not_in: [String!]
  creator_contains: String
  creator_contains_nocase: String
  creator_not_contains: String
  creator_not_contains_nocase: String
  creator_starts_with: String
  creator_starts_with_nocase: String
  creator_not_starts_with: String
  creator_not_starts_with_nocase: String
  creator_ends_with: String
  creator_ends_with_nocase: String
  creator_not_ends_with: String
  creator_not_ends_with_nocase: String
  startTime: BigInt
  startTime_not: BigInt
  startTime_gt: BigInt
  startTime_lt: BigInt
  startTime_gte: BigInt
  startTime_lte: BigInt
  startTime_in: [BigInt!]
  startTime_not_in: [BigInt!]
  endTime: BigInt
  endTime_not: BigInt
  endTime_gt: BigInt
  endTime_lt: BigInt
  endTime_gte: BigInt
  endTime_lte: BigInt
  endTime_in: [BigInt!]
  endTime_not_in: [BigInt!]
  to: [String!]
  to_not: [String!]
  to_contains: [String!]
  to_contains_nocase: [String!]
  to_not_contains: [String!]
  to_not_contains_nocase: [String!]
  data: [String!]
  data_not: [String!]
  data_contains: [String!]
  data_contains_nocase: [String!]
  data_not_contains: [String!]
  data_not_contains_nocase: [String!]
  value: [BigInt!]
  value_not: [BigInt!]
  value_contains: [BigInt!]
  value_contains_nocase: [BigInt!]
  value_not_contains: [BigInt!]
  value_not_contains_nocase: [BigInt!]
  title: String
  title_not: String
  title_gt: String
  title_lt: String
  title_gte: String
  title_lte: String
  title_in: [String!]
  title_not_in: [String!]
  title_contains: String
  title_contains_nocase: String
  title_not_contains: String
  title_not_contains_nocase: String
  title_starts_with: String
  title_starts_with_nocase: String
  title_not_starts_with: String
  title_not_starts_with_nocase: String
  title_ends_with: String
  title_ends_with_nocase: String
  title_not_ends_with: String
  title_not_ends_with_nocase: String
  contentHash: String
  contentHash_not: String
  contentHash_gt: String
  contentHash_lt: String
  contentHash_gte: String
  contentHash_lte: String
  contentHash_in: [String!]
  contentHash_not_in: [String!]
  contentHash_contains: String
  contentHash_contains_nocase: String
  contentHash_not_contains: String
  contentHash_not_contains_nocase: String
  contentHash_starts_with: String
  contentHash_starts_with_nocase: String
  contentHash_not_starts_with: String
  contentHash_not_starts_with_nocase: String
  contentHash_ends_with: String
  contentHash_ends_with_nocase: String
  contentHash_not_ends_with: String
  contentHash_not_ends_with_nocase: String
  contractState: BigInt
  contractState_not: BigInt
  contractState_gt: BigInt
  contractState_lt: BigInt
  contractState_gte: BigInt
  contractState_lte: BigInt
  contractState_in: [BigInt!]
  contractState_not_in: [BigInt!]
  guildId: String
  guildId_not: String
  guildId_gt: String
  guildId_lt: String
  guildId_gte: String
  guildId_lte: String
  guildId_in: [String!]
  guildId_not_in: [String!]
  guildId_contains: String
  guildId_contains_nocase: String
  guildId_not_contains: String
  guildId_not_contains_nocase: String
  guildId_starts_with: String
  guildId_starts_with_nocase: String
  guildId_not_starts_with: String
  guildId_not_starts_with_nocase: String
  guildId_ends_with: String
  guildId_ends_with_nocase: String
  guildId_not_ends_with: String
  guildId_not_ends_with_nocase: String
  totalVotes: [BigInt!]
  totalVotes_not: [BigInt!]
  totalVotes_contains: [BigInt!]
  totalVotes_contains_nocase: [BigInt!]
  totalVotes_not_contains: [BigInt!]
  totalVotes_not_contains_nocase: [BigInt!]
  votes: [String!]
  votes_not: [String!]
  votes_contains: [String!]
  votes_contains_nocase: [String!]
  votes_not_contains: [String!]
  votes_not_contains_nocase: [String!]
  votes_: Vote_filter
  options: [String!]
  options_not: [String!]
  options_contains: [String!]
  options_contains_nocase: [String!]
  options_not_contains: [String!]
  options_not_contains_nocase: [String!]
  options_: Option_filter
  metadata: String
  metadata_not: String
  metadata_gt: String
  metadata_lt: String
  metadata_gte: String
  metadata_lte: String
  metadata_in: [String!]
  metadata_not_in: [String!]
  metadata_contains: String
  metadata_contains_nocase: String
  metadata_not_contains: String
  metadata_not_contains_nocase: String
  metadata_starts_with: String
  metadata_starts_with_nocase: String
  metadata_not_starts_with: String
  metadata_not_starts_with_nocase: String
  metadata_ends_with: String
  metadata_ends_with_nocase: String
  metadata_not_ends_with: String
  metadata_not_ends_with_nocase: String
  description: String
  description_not: String
  description_gt: String
  description_lt: String
  description_gte: String
  description_lte: String
  description_in: [String!]
  description_not_in: [String!]
  description_contains: String
  description_contains_nocase: String
  description_not_contains: String
  description_not_contains_nocase: String
  description_starts_with: String
  description_starts_with_nocase: String
  description_not_starts_with: String
  description_not_starts_with_nocase: String
  description_ends_with: String
  description_ends_with_nocase: String
  description_not_ends_with: String
  description_not_ends_with_nocase: String
  executionTransactionHash: String
  executionTransactionHash_not: String
  executionTransactionHash_gt: String
  executionTransactionHash_lt: String
  executionTransactionHash_gte: String
  executionTransactionHash_lte: String
  executionTransactionHash_in: [String!]
  executionTransactionHash_not_in: [String!]
  executionTransactionHash_contains: String
  executionTransactionHash_contains_nocase: String
  executionTransactionHash_not_contains: String
  executionTransactionHash_not_contains_nocase: String
  executionTransactionHash_starts_with: String
  executionTransactionHash_starts_with_nocase: String
  executionTransactionHash_not_starts_with: String
  executionTransactionHash_not_starts_with_nocase: String
  executionTransactionHash_ends_with: String
  executionTransactionHash_ends_with_nocase: String
  executionTransactionHash_not_ends_with: String
  executionTransactionHash_not_ends_with_nocase: String
  statesLog: [String!]
  statesLog_not: [String!]
  statesLog_contains: [String!]
  statesLog_contains_nocase: [String!]
  statesLog_not_contains: [String!]
  statesLog_not_contains_nocase: [String!]
  statesLog_: ProposalStateLog_filter
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
}

enum Proposal_orderBy {
  id
  creator
  startTime
  endTime
  to
  data
  value
  title
  contentHash
  contractState
  guildId
  totalVotes
  votes
  options
  metadata
  description
  executionTransactionHash
  statesLog
}

type Query {
  proposal(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Proposal
  proposals(
    skip: Int = 0
    first: Int = 100
    orderBy: Proposal_orderBy
    orderDirection: OrderDirection
    where: Proposal_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [Proposal!]!
  proposalStateLog(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): ProposalStateLog
  proposalStateLogs(
    skip: Int = 0
    first: Int = 100
    orderBy: ProposalStateLog_orderBy
    orderDirection: OrderDirection
    where: ProposalStateLog_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [ProposalStateLog!]!
  option(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Option
  options(
    skip: Int = 0
    first: Int = 100
    orderBy: Option_orderBy
    orderDirection: OrderDirection
    where: Option_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [Option!]!
  action(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Action
  actions(
    skip: Int = 0
    first: Int = 100
    orderBy: Action_orderBy
    orderDirection: OrderDirection
    where: Action_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [Action!]!
  vote(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Vote
  votes(
    skip: Int = 0
    first: Int = 100
    orderBy: Vote_orderBy
    orderDirection: OrderDirection
    where: Vote_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [Vote!]!
  member(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Member
  members(
    skip: Int = 0
    first: Int = 100
    orderBy: Member_orderBy
    orderDirection: OrderDirection
    where: Member_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [Member!]!
  guild(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Guild
  guilds(
    skip: Int = 0
    first: Int = 100
    orderBy: Guild_orderBy
    orderDirection: OrderDirection
    where: Guild_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [Guild!]!
  token(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Token
  tokens(
    skip: Int = 0
    first: Int = 100
    orderBy: Token_orderBy
    orderDirection: OrderDirection
    where: Token_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [Token!]!
  guildPermission(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): GuildPermission
  guildPermissions(
    skip: Int = 0
    first: Int = 100
    orderBy: GuildPermission_orderBy
    orderDirection: OrderDirection
    where: GuildPermission_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [GuildPermission!]!
  """Access to subgraph metadata"""
  _meta(block: Block_height): _Meta_
}

type Subscription {
  proposal(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Proposal
  proposals(
    skip: Int = 0
    first: Int = 100
    orderBy: Proposal_orderBy
    orderDirection: OrderDirection
    where: Proposal_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [Proposal!]!
  proposalStateLog(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): ProposalStateLog
  proposalStateLogs(
    skip: Int = 0
    first: Int = 100
    orderBy: ProposalStateLog_orderBy
    orderDirection: OrderDirection
    where: ProposalStateLog_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [ProposalStateLog!]!
  option(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Option
  options(
    skip: Int = 0
    first: Int = 100
    orderBy: Option_orderBy
    orderDirection: OrderDirection
    where: Option_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [Option!]!
  action(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Action
  actions(
    skip: Int = 0
    first: Int = 100
    orderBy: Action_orderBy
    orderDirection: OrderDirection
    where: Action_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [Action!]!
  vote(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Vote
  votes(
    skip: Int = 0
    first: Int = 100
    orderBy: Vote_orderBy
    orderDirection: OrderDirection
    where: Vote_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [Vote!]!
  member(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Member
  members(
    skip: Int = 0
    first: Int = 100
    orderBy: Member_orderBy
    orderDirection: OrderDirection
    where: Member_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [Member!]!
  guild(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Guild
  guilds(
    skip: Int = 0
    first: Int = 100
    orderBy: Guild_orderBy
    orderDirection: OrderDirection
    where: Guild_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [Guild!]!
  token(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Token
  tokens(
    skip: Int = 0
    first: Int = 100
    orderBy: Token_orderBy
    orderDirection: OrderDirection
    where: Token_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [Token!]!
  guildPermission(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): GuildPermission
  guildPermissions(
    skip: Int = 0
    first: Int = 100
    orderBy: GuildPermission_orderBy
    orderDirection: OrderDirection
    where: GuildPermission_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [GuildPermission!]!
  """Access to subgraph metadata"""
  _meta(block: Block_height): _Meta_
}

type Token {
  id: ID!
  type: TokenType!
  name: String!
  symbol: String!
  decimals: Int!
  guildAddress: String!
}

enum TokenType {
  ERC20
}

input Token_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  type: TokenType
  type_not: TokenType
  type_in: [TokenType!]
  type_not_in: [TokenType!]
  name: String
  name_not: String
  name_gt: String
  name_lt: String
  name_gte: String
  name_lte: String
  name_in: [String!]
  name_not_in: [String!]
  name_contains: String
  name_contains_nocase: String
  name_not_contains: String
  name_not_contains_nocase: String
  name_starts_with: String
  name_starts_with_nocase: String
  name_not_starts_with: String
  name_not_starts_with_nocase: String
  name_ends_with: String
  name_ends_with_nocase: String
  name_not_ends_with: String
  name_not_ends_with_nocase: String
  symbol: String
  symbol_not: String
  symbol_gt: String
  symbol_lt: String
  symbol_gte: String
  symbol_lte: String
  symbol_in: [String!]
  symbol_not_in: [String!]
  symbol_contains: String
  symbol_contains_nocase: String
  symbol_not_contains: String
  symbol_not_contains_nocase: String
  symbol_starts_with: String
  symbol_starts_with_nocase: String
  symbol_not_starts_with: String
  symbol_not_starts_with_nocase: String
  symbol_ends_with: String
  symbol_ends_with_nocase: String
  symbol_not_ends_with: String
  symbol_not_ends_with_nocase: String
  decimals: Int
  decimals_not: Int
  decimals_gt: Int
  decimals_lt: Int
  decimals_gte: Int
  decimals_lte: Int
  decimals_in: [Int!]
  decimals_not_in: [Int!]
  guildAddress: String
  guildAddress_not: String
  guildAddress_gt: String
  guildAddress_lt: String
  guildAddress_gte: String
  guildAddress_lte: String
  guildAddress_in: [String!]
  guildAddress_not_in: [String!]
  guildAddress_contains: String
  guildAddress_contains_nocase: String
  guildAddress_not_contains: String
  guildAddress_not_contains_nocase: String
  guildAddress_starts_with: String
  guildAddress_starts_with_nocase: String
  guildAddress_not_starts_with: String
  guildAddress_not_starts_with_nocase: String
  guildAddress_ends_with: String
  guildAddress_ends_with_nocase: String
  guildAddress_not_ends_with: String
  guildAddress_not_ends_with_nocase: String
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
}

enum Token_orderBy {
  id
  type
  name
  symbol
  decimals
  guildAddress
}

type Vote {
  id: ID!
  proposalId: String!
  option: BigInt!
  optionLabel: String
  voter: String!
  votingPower: BigInt!
  transactionHash: String!
}

input Vote_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  proposalId: String
  proposalId_not: String
  proposalId_gt: String
  proposalId_lt: String
  proposalId_gte: String
  proposalId_lte: String
  proposalId_in: [String!]
  proposalId_not_in: [String!]
  proposalId_contains: String
  proposalId_contains_nocase: String
  proposalId_not_contains: String
  proposalId_not_contains_nocase: String
  proposalId_starts_with: String
  proposalId_starts_with_nocase: String
  proposalId_not_starts_with: String
  proposalId_not_starts_with_nocase: String
  proposalId_ends_with: String
  proposalId_ends_with_nocase: String
  proposalId_not_ends_with: String
  proposalId_not_ends_with_nocase: String
  option: BigInt
  option_not: BigInt
  option_gt: BigInt
  option_lt: BigInt
  option_gte: BigInt
  option_lte: BigInt
  option_in: [BigInt!]
  option_not_in: [BigInt!]
  optionLabel: String
  optionLabel_not: String
  optionLabel_gt: String
  optionLabel_lt: String
  optionLabel_gte: String
  optionLabel_lte: String
  optionLabel_in: [String!]
  optionLabel_not_in: [String!]
  optionLabel_contains: String
  optionLabel_contains_nocase: String
  optionLabel_not_contains: String
  optionLabel_not_contains_nocase: String
  optionLabel_starts_with: String
  optionLabel_starts_with_nocase: String
  optionLabel_not_starts_with: String
  optionLabel_not_starts_with_nocase: String
  optionLabel_ends_with: String
  optionLabel_ends_with_nocase: String
  optionLabel_not_ends_with: String
  optionLabel_not_ends_with_nocase: String
  voter: String
  voter_not: String
  voter_gt: String
  voter_lt: String
  voter_gte: String
  voter_lte: String
  voter_in: [String!]
  voter_not_in: [String!]
  voter_contains: String
  voter_contains_nocase: String
  voter_not_contains: String
  voter_not_contains_nocase: String
  voter_starts_with: String
  voter_starts_with_nocase: String
  voter_not_starts_with: String
  voter_not_starts_with_nocase: String
  voter_ends_with: String
  voter_ends_with_nocase: String
  voter_not_ends_with: String
  voter_not_ends_with_nocase: String
  votingPower: BigInt
  votingPower_not: BigInt
  votingPower_gt: BigInt
  votingPower_lt: BigInt
  votingPower_gte: BigInt
  votingPower_lte: BigInt
  votingPower_in: [BigInt!]
  votingPower_not_in: [BigInt!]
  transactionHash: String
  transactionHash_not: String
  transactionHash_gt: String
  transactionHash_lt: String
  transactionHash_gte: String
  transactionHash_lte: String
  transactionHash_in: [String!]
  transactionHash_not_in: [String!]
  transactionHash_contains: String
  transactionHash_contains_nocase: String
  transactionHash_not_contains: String
  transactionHash_not_contains_nocase: String
  transactionHash_starts_with: String
  transactionHash_starts_with_nocase: String
  transactionHash_not_starts_with: String
  transactionHash_not_starts_with_nocase: String
  transactionHash_ends_with: String
  transactionHash_ends_with_nocase: String
  transactionHash_not_ends_with: String
  transactionHash_not_ends_with_nocase: String
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
}

enum Vote_orderBy {
  id
  proposalId
  option
  optionLabel
  voter
  votingPower
  transactionHash
}

type _Block_ {
  """The hash of the block"""
  hash: Bytes
  """The block number"""
  number: Int!
  """Integer representation of the timestamp stored in blocks for the chain"""
  timestamp: Int
}

"""The type for the top-level _meta field"""
type _Meta_ {
  """
  Information about a specific subgraph block. The hash of the block
  will be null if the _meta field has a block constraint that asks for
  a block number. It will be filled if the _meta field has no block constraint
  and therefore asks for the latest  block
  
  """
  block: _Block_!
  """The deployment ID"""
  deployment: String!
  """If `true`, the subgraph encountered indexing errors at some past block"""
  hasIndexingErrors: Boolean!
}

enum _SubgraphErrorPolicy_ {
  """Data will be returned even if the subgraph has indexing errors"""
  allow
  """
  If the subgraph has indexing errors, data will be omitted. The default.
  """
  deny
}